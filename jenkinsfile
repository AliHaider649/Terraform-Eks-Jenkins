// Jenkinsfile - Declarative Pipeline for Terraform (Windows / cross-platform friendly)
//
// Assumptions:
// - Terraform and AWS CLI are installed on the Jenkins agent (or master) PATH
// - Jenkins has credentials created (see README below for IDs)
// - This pipeline runs 'terraform' commands from repo root
//
// Credentials required in Jenkins:
// - AWS_ACCESS_KEY_ID  (credential type: Secret text)  -> id: aws_access_key_id
// - AWS_SECRET_ACCESS_KEY (credential type: Secret text) -> id: aws_secret_access_key
// - Optional: TF_VAR_* secrets or other secrets can be added via Jenkins Credentials

pipeline {
  agent any

  environment {
    // Set region and tf var file name (edit if using other var-file)
    AWS_REGION = 'us-east-1'
    // TF_VAR_file = 'terraform.tfvars'            // adapt if you use different name
    // You may override these with pipeline parameters or credentials if desired
    TF_WORKING_DIR = '.'                        // terraform root (repo root)
  }

  options {
    timestamps()
    ansiColor('xterm')
    buildDiscarder(logRotator(numToKeepStr: '50'))
  }

  parameters {
    booleanParam(name: 'AUTO_APPLY', defaultValue: false, description: 'If true, pipeline runs terraform apply automatically after plan (careful!). Default false -> requires manual Approval.')
  }

  stages {

    stage('Checkout') {
      steps {
        checkout scm
      }
    }

    stage('Prepare - Tool versions') {
      steps {
        echo "Checking versions: terraform, aws, kubectl (if installed)"
        sh(script: 'terraform -version || echo "terraform not found"', returnStatus: false)
        sh(script: 'aws --version || echo "aws cli not found"', returnStatus: false)
        sh(script: 'kubectl version --client || echo "kubectl not found"', returnStatus: false)
      }
    }

    stage('Terraform Init') {
      steps {
        withCredentials([
          string(credentialsId: 'aws_access_key_id', variable: 'AWS_ACCESS_KEY_ID'),
          string(credentialsId: 'aws_secret_access_key', variable: 'AWS_SECRET_ACCESS_KEY')
        ]) {
          // export to environment so terraform can use them
          sh """
            export AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID}
            export AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}
            export AWS_DEFAULT_REGION=${AWS_REGION}
            cd ${TF_WORKING_DIR}
            terraform init -input=false
          """
        }
      }
    }

    stage('Terraform Validate & Fmt') {
      steps {
        sh """
          cd ${TF_WORKING_DIR}
          terraform fmt -check || (echo "Formatting issue: run terraform fmt" && exit 1)
          terraform validate
        """
      }
    }

    stage('Terraform Plan') {
      steps {
        withCredentials([
          string(credentialsId: 'aws_access_key_id', variable: 'AWS_ACCESS_KEY_ID'),
          string(credentialsId: 'aws_secret_access_key', variable: 'AWS_SECRET_ACCESS_KEY')
        ]) {
          // create a binary plan to allow safe apply
          sh """
            export AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID}
            export AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}
            export AWS_DEFAULT_REGION=${AWS_REGION}
            cd ${TF_WORKING_DIR}
            terraform plan -input=false 
            
          """
          // Archive the plan text for review
          // archiveArtifacts allowEmptyArchive: false, artifacts: "${TF_WORKING_DIR}/tfplan.txt", fingerprint: true
        }
      }
    }

    stage('Approve & Apply') {
      when {
        expression { return params.AUTO_APPLY == false }
      }
      steps {
        // Manual approval step - will pause pipeline until user clicks Proceed
        input message: "Approve terraform apply to ${env.BUILD_TAG} ? (This will modify infrastructure)", ok: 'Apply'
        withCredentials([
          string(credentialsId: 'aws_access_key_id', variable: 'AWS_ACCESS_KEY_ID'),
          string(credentialsId: 'aws_secret_access_key', variable: 'AWS_SECRET_ACCESS_KEY')
        ]) {
          sh """
            export AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID}
            export AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}
            export AWS_DEFAULT_REGION=${AWS_REGION}
            cd ${TF_WORKING_DIR}
            terraform apply  -auto-approve 
          """
        }
      }
    }

    stage('Auto Apply (if enabled)') {
      when {
        expression { return params.AUTO_APPLY == true }
      }
      steps {
        withCredentials([
          string(credentialsId: 'aws_access_key_id', variable: 'AWS_ACCESS_KEY_ID'),
          string(credentialsId: 'aws_secret_access_key', variable: 'AWS_SECRET_ACCESS_KEY')
        ]) {
          sh """
            export AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID}
            export AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}
            export AWS_DEFAULT_REGION=${AWS_REGION}
            cd ${TF_WORKING_DIR}
            terraform apply -auto-approve
          """
        }
      }
    }

  } // stages

  post {
    success {
      echo "Pipeline finished successfully"
      archiveArtifacts artifacts: "${TF_WORKING_DIR}/terraform.tfstate", allowEmptyArchive: true
    }
    failure {
      mail to: 'alihaid649@example.com', subject: "Jenkins Pipeline Failed: ${currentBuild.fullDisplayName}", body: "Build failed: ${env.BUILD_URL}"
    }
  }
}
